<html>
  <title>arboard</title>

  <button id="debug">Click</button>

  <script src="vendor/artoolkit.debug.js"></script>
  <!-- <script src="vendor/artoolkit.min.js"></script> -->
  <script src="vendor/artoolkit.api.js"></script>
  <script src="vendor/three.min.js"></script>
  <script src="vendor/artoolkit.three.js"></script>

  <script>
    THREE.Object3D.prototype.setVisible = function(visible) {
      return this.traverse(function(object) { object.visible = visible; });
    };

    var average = function(data) {
      var sum = data.reduce(function(sum, value){
        return sum + value;
      }, 0);

      var avg = sum / data.length;
      return avg;
    };

    var standardDeviation = function(values) {
      var averageValue = average(values);
      var squareDiffs = values.map(function(value) {
        var diff = value - averageValue;
        var sqrDiff = diff * diff;
        return sqrDiff;
      });

      return Math.sqrt(average(squareDiffs));
    };

    var roundRotation = function(value) {
      return value < 0 ? (value + 2 * Math.PI) : value;
    };

    var rotationDifference = function(a, b) {
      return Math.sqrt(
        Math.pow(roundRotation(a.x) - roundRotation(b.x), 2) +
        Math.pow(a.y - b.y, 2) +
        Math.pow(a.z - b.z, 2)
      );
    };

    ARController.getUserMediaThreeScene({
      maxARVideoSize: 640,
      cameraParam: 'vendor/camera_para-iPhone_5_rear_640x480_1.0m.dat',
      onSuccess: function(scene, controller) {
        controller.setPatternDetectionMode(artoolkit.AR_MATRIX_CODE_DETECTION);
        controller.setPattRatio(150/226);
        controller.setMatrixCodeType(artoolkit.AR_MATRIX_CODE_4x4_BCH_13_9_3);

        var renderer = new THREE.WebGLRenderer({antialias: false});
        renderer.setSize(controller.videoWidth, controller.videoHeight);

        document.body.insertBefore(renderer.domElement, document.body.firstChild);

        var light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(0, -1, -1);
        scene.scene.add(light);

        var blueMaterial = new THREE.MeshLambertMaterial({ color: 'blue', side: THREE.DoubleSide });
        var redMaterial = new THREE.MeshLambertMaterial({ color: 'red', side: THREE.DoubleSide });
        var normalMaterial = new THREE.MeshNormalMaterial();

        var markers = [];
        for (var i = 0; i < 512; i++) {
          var marker = new THREE.Object3D();
          marker.id = i;
          //marker.matrixAutoUpdate = false;
          marker.position.z = -5;

          var box = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 0.3),
            normalMaterial
          );
          //box.position.z = -0.5;
          marker.add(box);
          marker.box = box;

          scene.scene.add(marker);
          markers.push(marker);
        }

        controller.addEventListener('getMarker', function(ev) {
          if (ev.data.marker.idMatrix >= 0 && ev.data) {
            var marker = markers[ev.data.marker.idMatrix];
            marker.matrix.elements.set(ev.data.matrix);
            marker.matrix.decompose(marker.position, marker.quaternion, new THREE.Vector3());
            marker.active = 5;
            marker.setVisible(true);
          }
        });

        document.getElementById('debug').addEventListener('click', function() {
          var actives = markers.filter(function(marker) {
            return marker.active;
          }).map(function(marker) {
            console.log(marker.rotation);
          });
        });

        var tick = function() {
          var actives = markers.filter(function(marker) {
            return marker.active;
          });

          var index = actives.map(function(marker) {
            return rotationDifference(actives[0].rotation, marker.rotation);
          }).reduce(function(maxIndex, difference, index, array) {
            return difference > array[maxIndex] ? index : maxIndex;
          }, 0);

          // if (actives[0]) console.log(actives[0].rotation);

          // if (index > 0) {
          //   console.log(rotationDifference(actives[0].rotation, actives[index].rotation));
          // }

          if (index > 0 && rotationDifference(actives[0].rotation, actives[index].rotation) > 0.5) {
            var groups = [
              [actives[0]],
              [actives[index]],
            ];

            actives.map(function(marker, i) {
              if (i !== 0 && i !== index) {
                var a = rotationDifference(groups[0][0].rotation, marker.rotation);
                var b = rotationDifference(groups[1][0].rotation, marker.rotation);
                groups[a < b ? 0 : 1].push(marker);
              }
            });

            if (groups[1].length > groups[0].length) {
              groups = [groups[1], groups[0]];
            }
          }
          else {
            var groups = [actives, []];
          }

          // console.log(groups[0].length, groups[1].length);

          groups[0].map(function(marker) {
            marker.box.material = redMaterial;
            marker.box.quaternion.copy(new THREE.Quaternion())
          });
          groups[1].map(function(marker) {
            marker.box.material = blueMaterial;
            marker.box.quaternion.copy(marker.quaternion).conjugate().multiply(groups[0][0].quaternion);
          });

          //console.log(actives.length, groups[0].length, groups[1].length);
          //console.log(actives.map(function(marker) { return marker.id; }));

          // var averageRotation = {
          //   x: average(actives.map(function(marker) { return marker.rotation.x; })),
          //   y: average(actives.map(function(marker) { return marker.rotation.y; })),
          //   z: average(actives.map(function(marker) { return marker.rotation.z; })),
          // };

          // var deviation = standardDeviation(actives.map(function(marker) {
          //   return rotationDifference(marker.rotation, averageRotation);
          // }));

          // actives.map(function(marker) {
          //   marker.flipRotation = rotationDifference(marker.rotation, averageRotation) > deviation * 0.8;
          // });

          // var correct = actives.filter(function(marker) {
          //   return !marker.flipRotation;
          // });

          // var correctRotation = {
          //   x: average(correct.map(function(marker) { return marker.rotation.x; })),
          //   y: average(correct.map(function(marker) { return marker.rotation.y; })),
          //   z: average(correct.map(function(marker) { return marker.rotation.z; })),
          // };

          //correct.map(function(marker) {
          //  marker.box.material = normalMaterial;
          //});

          // actives.filter(function(marker) {
          //   return marker.flipRotation;
          // }).map(function(marker) {
          //   marker.box.material = redMaterial;
          //   marker.rotation.set(correctRotation.x, correctRotation.y, correctRotation.z);
          //   marker.quaternion.setFromEuler(marker.rotation);
          //   marker.updateMatrix();
          // });

          scene.process();
          scene.renderOn(renderer);

          markers.map(function(marker) {
            if (marker.active > 0) marker.active--;
            else marker.setVisible(false);
          });

          requestAnimationFrame(tick);
        };

        tick();
      }
    });

    delete window.ARThreeOnLoad;

  </script>

</html>
